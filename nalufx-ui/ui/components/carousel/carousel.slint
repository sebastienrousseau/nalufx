import { Theme } from "../../theme.slint";
import { Images } from "../../images.slint";
import { Card } from "../card/card.slint";

/// Defines the type of carousel behavior.
export enum CarouselType {
    Linear,
    Rotary,
}

/// A customizable carousel component for displaying a series of images.
export component Carousel inherits Rectangle {
    /// The list of image sources to display in the carousel.
    in-out property <[image]> sources;

    /// The type of carousel behavior (Linear or Rotary).
    in property <CarouselType> type: CarouselType.Linear;

    /// The stretch factor for non-active items.
    in property <float> fold-stretch: 1.0;

    /// The width of non-active items.
    in property <length> fold-width: 100px;

    /// The height of the carousel.
    in property <length> fold-height: root.height;

    /// Whether to focus on the main (active) item.
    in property <bool> focus-main: true;

    /// The index of the currently active item.
    in-out property <int> active: 0;

    /// Callback triggered when an item is clicked.
    callback clicked(int);

    // Private properties
    private property <[image]> phantoms: self.sources;
    private property <int> center-index: Math.max(0, Math.round(sources.length / 2) - 1);
    private property <image> tmp;

    /// Updates the phantom images for the rotary carousel type.
    function update-phantoms() {
        if (type == CarouselType.Rotary && sources.length > 0) {
            tmp = root.phantoms[center-index];
            root.phantoms[center-index] = root.phantoms[root.active];
            root.phantoms[root.active] = tmp;
        }
    }

    /// Calculates the scale factor for an item based on its position.
    function get-item-scale(index: int) -> float {
        if (type == CarouselType.Linear) {
            return root.active == index ? 1 : 0.3;
        } else {
            if (index >= center-index) {
                return 1 - (index - center-index) * 0.7 / (sources.length / 2);
            } else {
                return 1 - (center-index - index) * 0.7 / (sources.length / 2);
            }
        }
    }

    /// Calculates the width of an item based on its index.
    function get-item-width(index: int) -> length {
        if (sources.length == 0) { return 0px; }

        if (type == CarouselType.Linear) {
            if (root.active == index) {
                return (root.width - (sources.length * fold-width) - (layout.spacing * 2)) * get-item-scale(index);
            } else {
                return fold-width * get-item-scale(index);
            }
        } else {
            if (index == center-index) {
                return (root.width - (sources.length * fold-width) - (layout.spacing * 2)) * get-item-scale(index);
            } else {
                return fold-width * get-item-scale(index);
            }
        }
    }

    /// Calculates the height of an item based on its index.
    function get-item-height(index: int) -> length {
        if (sources.length == 0) { return 0px; }
        return root.fold-height * get-item-scale(index);
    }

    /// Calculates the border radius of an item based on its index.
    function get-item-border-radius(index: int) -> length {
        if (sources.length == 0) { return 0px; }
        if (type == CarouselType.Linear) {
            return root.active == index ? 0px : fold-width / 2;
        } else {
            return index == center-index ? 0px : fold-width / 2;
        }
    }

    /// Rotates the carousel to the left.
    function rotate-left() {
        if (sources.length == 0) { return; }
        if (root.active > 0) {
            root.active -= 1;
        } else {
            root.active = root.sources.length - 1;
        }
        update-phantoms();
    }

    /// Rotates the carousel to the right.
    function rotate-right() {
        if (sources.length == 0) { return; }
        if (root.active < root.sources.length - 1) {
            root.active += 1;
        } else {
            root.active = 0;
        }
        update-phantoms();
    }

    /// Handles item click events.
    function handle-item-click(index: int) {
        if (sources.length == 0) { return; }
        if (index == 0) {
            rotate-left();
        } else if (index == root.sources.length - 1) {
            rotate-right();
        }
        root.clicked(root.active);
    }

    layout := HorizontalLayout {
        alignment: center;
        spacing: 16px;
        for source[index] in (type == CarouselType.Linear ? root.sources : root.phantoms): Rectangle {
            width: get-item-width(index);
            height: get-item-height(index);
            clip: true;
            animate width, height {
                duration: 250ms;
                easing: ease-in-out;
            }
            Image {
                width: parent.width;
                height: parent.height;
                source: source;
                image-fit: contain;
                colorize: Theme.palette.transparent;
                animate colorize {
                    duration: 125ms;
                }
            }
            TouchArea {
                visible: index == 0 || index == root.sources.length - 1;
                clicked => {
                    handle-item-click(index);
                }
            }
        }
    }

    /// Handles keyboard navigation.
    forward-focus: key-handler;
    key-handler := FocusScope {
        key-pressed(event) => {
            if (event.text == Key.LeftArrow) {
                rotate-left();
                return accept;
            }
            if (event.text == Key.RightArrow) {
                rotate-right();
                return accept;
            }
            return reject;
        }
    }
}
